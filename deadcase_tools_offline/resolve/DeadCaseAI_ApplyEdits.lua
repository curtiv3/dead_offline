-- DeadCaseAI_ApplyEdits.lua
-- Place this file in:
--   %APPDATA%/Blackmagic Design/DaVinci Resolve/Support/Fusion/Scripts/Edit/
-- Then restart Resolve and run via: Workspace → Scripts → Edit → DeadCaseAI_ApplyEdits
--
-- This script asks for an edit_map.json generated by offline_director.py and
-- applies its events as colored markers to the current timeline.

-- Lightweight JSON decoder (no external dependencies).
-- Trims whitespace.
local function json_next_char(str, idx)
  local _, next_idx = str:find("^%s*", idx)
  return next_idx + 1
end

local function json_parse_value(str, idx)
  idx = json_next_char(str, idx)
  local c = str:sub(idx, idx)
  if c == '"' then
    local res = {}
    idx = idx + 1
    while idx <= #str do
      local ch = str:sub(idx, idx)
      if ch == '"' then
        return table.concat(res), idx + 1
      elseif ch == "\\" then
        local nxt = str:sub(idx + 1, idx + 1)
        local map = { ['"'] = '"', ['\\'] = '\\', ['/'] = '/', ['b'] = '\b', ['f'] = '\f', ['n'] = '\n', ['r'] = '\r', ['t'] = '\t' }
        table.insert(res, map[nxt] or nxt)
        idx = idx + 2
      else
        table.insert(res, ch)
        idx = idx + 1
      end
    end
    error("Unterminated string in JSON")
  elseif c == '{' then
    local obj = {}
    idx = idx + 1
    idx = json_next_char(str, idx)
    if str:sub(idx, idx) == '}' then
      return obj, idx + 1
    end
    while idx <= #str do
      local key
      key, idx = json_parse_value(str, idx)
      idx = json_next_char(str, idx)
      if str:sub(idx, idx) ~= ':' then
        error("Expected ':' after key in object")
      end
      idx = json_parse_value(str, idx + 1)
      local val
      val, idx = json_parse_value(str, idx)
      obj[key] = val
      idx = json_next_char(str, idx)
      local delim = str:sub(idx, idx)
      if delim == '}' then
        return obj, idx + 1
      elseif delim ~= ',' then
        error("Expected ',' or '}' in object")
      end
      idx = idx + 1
    end
    error("Unterminated object in JSON")
  elseif c == '[' then
    local arr = {}
    idx = idx + 1
    idx = json_next_char(str, idx)
    if str:sub(idx, idx) == ']' then
      return arr, idx + 1
    end
    while idx <= #str do
      local val
      val, idx = json_parse_value(str, idx)
      table.insert(arr, val)
      idx = json_next_char(str, idx)
      local delim = str:sub(idx, idx)
      if delim == ']' then
        return arr, idx + 1
      elseif delim ~= ',' then
        error("Expected ',' or ']' in array")
      end
      idx = idx + 1
    end
    error("Unterminated array in JSON")
  elseif c == '-' or c:match('%d') then
    local s, e = str:find("^-?%d+%.?%d*[eE]?[+-]?%d*", idx)
    local num = tonumber(str:sub(s, e))
    if num == nil then
      error("Invalid number in JSON")
    end
    return num, e + 1
  elseif str:sub(idx, idx + 3) == "true" then
    return true, idx + 4
  elseif str:sub(idx, idx + 4) == "false" then
    return false, idx + 5
  elseif str:sub(idx, idx + 3) == "null" then
    return nil, idx + 4
  else
    error("Unexpected character in JSON at position " .. idx)
  end
end

local function json_decode(str)
  local ok, result = pcall(function()
    local val, next_idx = json_parse_value(str, 1)
    next_idx = json_next_char(str, next_idx)
    if next_idx <= #str then
      error("Trailing content after JSON value")
    end
    return val
  end)
  if ok then
    return result
  end
  return nil, result
end

local function read_file(path)
  local fh, err = io.open(path, "r")
  if not fh then
    return nil, err
  end
  local data = fh:read("*a")
  fh:close()
  return data
end

local function load_edit_map(path)
  local content, err = read_file(path)
  if not content then
    return nil, "Could not open edit map: " .. (err or "unknown error")
  end
  local data, decode_err = json_decode(content)
  if not data then
    return nil, "JSON decode failed: " .. tostring(decode_err)
  end
  if type(data) ~= "table" then
    return nil, "edit_map.json does not contain a list"
  end
  return data
end

local function get_timeline()
  local resolve = Resolve()
  if not resolve then
    print("DeadCaseAI: Resolve scripting API not available.")
    return nil, nil, nil
  end
  local pm = resolve:GetProjectManager()
  if not pm then
    print("DeadCaseAI: Could not access Project Manager.")
    return nil, nil, nil
  end
  local project = pm:GetCurrentProject()
  if not project then
    print("DeadCaseAI: No active project.")
    return nil, nil, nil
  end
  local timeline = project:GetCurrentTimeline()
  if not timeline then
    print("DeadCaseAI: No active timeline.")
    return nil, nil, nil
  end
  return timeline, project, resolve
end

local function color_for_event(event)
  local action = event.action or "marker"
  local label = event.label or ""
  if action == "marker" then
    local lower = label:lower()
    if lower:find("tension") then
      return "Red"
    elseif lower:find("beat") or lower:find("shot_") then
      return "Blue"
    else
      return "Cyan"
    end
  elseif action == "cut" then
    return "Yellow"
  elseif action == "glitch" then
    return "Magenta"
  elseif action == "flash" then
    return "White"
  else
    return "Green"
  end
end

local function build_marker_text(event)
  local action = event.action or "marker"
  local label = event.label or action
  local note_parts = {}
  if event.reason then table.insert(note_parts, "reason=" .. tostring(event.reason)) end
  if event.duration then table.insert(note_parts, "duration=" .. tostring(event.duration)) end
  if event.intensity then table.insert(note_parts, "intensity=" .. tostring(event.intensity)) end
  local note = table.concat(note_parts, ", ")
  if action == "cut" then
    return "CUT_POINT", note ~= "" and note or ""
  elseif action == "glitch" then
    local name = "GLITCH" .. (event.intensity and " (" .. tostring(event.intensity) .. ")" or "")
    return name, note
  elseif action == "flash" then
    return "FLASH", note
  elseif action == "marker" then
    return label ~= "" and label or "marker", note
  else
    return tostring(action), note
  end
end

local function apply_events(timeline, events)
  table.sort(events, function(a, b)
    return (tonumber(a.time) or 0) < (tonumber(b.time) or 0)
  end)

  local fps = tonumber(timeline:GetSetting("timelineFrameRate")) or 24
  local applied = 0

  for _, event in ipairs(events) do
    local time_sec = tonumber(event.time)
    if time_sec then
      local color = color_for_event(event)
      local name, note = build_marker_text(event)
      local duration_frames = 1
      if event.duration then
        duration_frames = math.max(1, math.floor((tonumber(event.duration) or 0) * fps))
      end
      timeline:AddMarker(time_sec, color, name, note, duration_frames)
      applied = applied + 1
    end
  end
  return applied
end

local function request_edit_map_path(resolve)
  local fusion = resolve and resolve:Fusion()
  if fusion and fusion.RequestFile then
    return fusion:RequestFile("Select edit_map.json", "*.json")
  end
  io.write("Path to edit_map.json (blank to cancel): ")
  return io.read()
end

local function main()
  local timeline, project, resolve = get_timeline()
  if not timeline then
    return
  end

  local path = request_edit_map_path(resolve)
  if not path or path == "" then
    print("DeadCaseAI: No file selected. Aborting.")
    return
  end

  local events, err = load_edit_map(path)
  if not events then
    print("DeadCaseAI: " .. err)
    return
  end

  if #events == 0 then
    print("DeadCaseAI: No events in edit_map.json")
    return
  end

  local count = apply_events(timeline, events)
  print("DeadCaseAI: applied " .. tostring(count) .. " events from " .. path)
end

main()
